/*{
    "author": "Josh Hughes",
    "targets": ["omnifocus"],
    "type": "action",
    "version": "1.1",
    "description": "Toggle a given tag",
    "label" : "Toggle Tag"
}*/
(() => {

    // INSTRUCTIONS:
    // Replace 'NAME OF TAG' with the tag you would like to toggle.
    // If, when this plugin adds the given tag, you would like it to remove all
    // sibling tags as well, set removeSiblingTags to true (no quotes)

    const options = {
        'tagName'           : 'NAME OF TAG',
        'removeSiblingTags' : false
    }
        
    const tagableItems = (objects) => {
        return objects.filter(item => (item instanceof Task || item instanceof Project));
    }
    
    const allSelectedItemsHaveTag = (selection, selectedTag) => {
        for (let i = 0; i < selection.length; i++) {
            if (!new Set(selection[i].tags).has(selectedTag)) {
                return false;
            }
        }
        return true;
    }
    
    const findTagAndSiblings = (options, tagGroup) => {
        let searchResult = false;
        if (options && options.tagName) {
            if (typeof tagGroup === 'undefined') {
                tagGroup = tags;
            }
            if (tagGroup.length > 0) {
                for (let i = 0; i < tagGroup.length; i++) {
                    testedTag = tagGroup[i];
                    if (testedTag.name === options.tagName) {
                        searchResult = {
                            'selectedTag' : testedTag,
                            'siblingTags' : tagGroup.filter(tag => tag !== testedTag)
                        };
                        break;
                    } else {
                        let childTest = findTagAndSiblings(options, testedTag.tags);
                        if (childTest) {
                            searchResult = childTest;
                            break;
                        }
                    }
                }
            }
        }
        return searchResult;
    }

    const toggleTag = (selection, options) => {
        const items          = tagableItems(selection.allObjects),
              tagAndSiblings = findTagAndSiblings(options);
        
        if (items[0] && tagAndSiblings && tagAndSiblings.selectedTag) {
            if (allSelectedItemsHaveTag(items, tagAndSiblings.selectedTag)) {
                items.forEach(item => item.removeTag(tagAndSiblings.selectedTag));
            } else {
                items.forEach((item) => {                    
                    if (options.removeSiblingTags) {
                        let currentActionTags = item.tags;
                        let newTags = [];
                        let foundSiblingTag = false;
                        for (let i = 0; i < currentActionTags.length; i++) {
                            if (tagAndSiblings.siblingTags.includes(currentActionTags[i])) {
                                // If we find an existing sibling tag, and haven't added the new tag yet, push that instead
                                if (!foundSiblingTag) {
                                    newTags.push(tagAndSiblings.selectedTag);
                                    foundSiblingTag = true;
                                }
                            } else {
                                newTags.push(currentActionTags[i]);
                            }
                        }
                        // If there we're no siblings, add the tag to the end
                        if (!foundSiblingTag) {
                            newTags.push(tagAndSiblings.selectedTag);
                        }

                        if (!item.tags.includes(tagAndSiblings.selectedTag) || foundSiblingTag) {
                            item.clearTags();
                            item.addTags(newTags);
                        }
                    } else {
                        if (!item.tags.includes(tagAndSiblings.selectedTag)) {
                            item.addTag(tagAndSiblings.selectedTag);
                        }
                    }
                });
            }
        }
    }

    const validateTag = (selection, options, sender) => {
        const items          = tagableItems(selection.allObjects),
              tagAndSiblings = findTagAndSiblings(options);

        if (tagAndSiblings && tagAndSiblings.selectedTag && items[0]) {
            if (typeof sender !== 'undefined') {
                sender.checked = allSelectedItemsHaveTag(items, tagAndSiblings.selectedTag);
            }
            return true;
        }
        
        if (!tagAndSiblings.selectedTag && typeof sender !== 'undefined') {
            if (sender.label && sender.label.slice(-12) !== ' (Not Found)') {
                sender.label += ' (Not Found)';
            }
        }
        return false;
    };
    
    const action = new PlugIn.Action(function (selection) {
        toggleTag(selection, options);
    });
    
    action.validate = function (selection, sender) {
        return validateTag(selection, options, sender);
    }
    return action;
})();
